

    二封筒問題のシミュレーション
    (Created: 2020-11-02, Time-stamp: <2020-11-05T23:53:09Z>)


** 目次

  * その１ 基礎編
  * その２ 実数拡張編
  * その３ 整数拡張編



    二封筒問題のシミュレーション その１ 基礎編


** 概要

二封筒問題(参: 三浦俊彦『可能世界の哲学』)を Python を用いたシミュレー
ションで解く。

最初は誤解して、「求めているのは、単に、相手を見たとき相手の額が自分の
何倍かを調べると平均で 1.25 倍になるということ。交換したとしてもしなかっ
たとしてもそうなる。じゃあ、交換すれば結果が変わるかというと変わらな
い。開封も未開封も関係ない。」と考えた。

しかし、その後、開封バージョンを実際にシミュレーションをすれば、確かに
交換したら 1.25 倍になるということが(予想外にも)示せた。この「その１」
では、その「驚き」までを示す。

そして、その２、その３では、なぜそうなるかを示すために議論を実数バージョ
ン、一般的な整数バージョンに拡張する。


** はじめに

三浦俊彦『可能世界の哲学』によると「二封筒問題」とは次のような問題であ
る。

> あなたはゲームのプレイヤーです。胴元が、二つの見分けのつかない封筒を
> 提示して、こう言います。「どちらか一方を取ってください。それぞれ金額
> の書かれた小切手が入っっていて、取った方の金額を差し上げますよ。ちな
> みに、一方は他方の２倍の金額なんですけどね」
>
> あなたは左の封筒を取りました。そして、開封しないまま、胴元が最初に言っ
> た言葉を思い出します。「ファイナルアンサーを決める前に、一度だけ、選
> 択を変えるチャンスが与えられている」と。
>
> あなたは考えます。いま手に取った封筒内金額をＡ円としよう。あっちの封
> 筒の中にあるのは、２Ａ円かＡ／２円か、どちらかだ。確率は五分五分。で
> は、交換した場合の期待値を求めてみよう。２Ａ／２＋（Ａ／２）／２=５
> Ａ／４。交換しなかった場合の期待値はもちろんＡ。
>
> そうか、Ａがいくらであるかにかかわらず、交換すると期待値はＡ／４だけ
> 多くなるぞ。交換しよう！
>
> さあどうでしょう。この計算は正しいでしょうか。そして、交換すると実際
> に得なのでしょうか。(p.270-271)

もし、得だとすれば、交換したあと、また同じように考えるとまた交換すべき
となり、交換によって 5(5A/4)/4 に期待値が大きくなる。そして続けると交
換するだけで無限に期待値が大きくなる。…

そんなことは起こるはずはない。三浦もここでは、交換しても得をすることは
ないと答えている。

ただし、封筒が未開封の場合と限る。…と。

> 自分が選んだ封筒をあなたは交換しないまま開封しました。小切手に１万円
> と書かれていました。ここであなたは胴元が最初に言った言葉を思い出しま
> す。「ファイナルアンサーを決める前に、一度だけ、選択を変えるチャンス
> が与えられている。選択変更は、最初に選んだ封筒を開封して金額を見てか
> らでもけっこうである」と。(p.274)

こうすると、確かに交換すると金額の期待値は A/4 だけ大きくなるというの
だ。


** 私の誤解

何かがおかしい。１万円というのは仮の値で、そこはいくらでもいいはずであ
る。元の封筒の額を A、もう一つの封筒の額を B としよう。もし、交換が得
なら B/A を集計すれば、その値が 1 ではなく 1.25 になるはずだ。…と私は
考えた。

そこで作ってみたのが下の two_envelopes_1.py である。元の封筒の額を a、
もう一つの封筒の額を b、基準となる額を x、コインの表裏で a と b どちら
に二倍入れるかを r (r == 0 で a に二倍、r == 1 で b に二倍)とした。

<source>
import random
import numpy as np
import argparse
ARGS = argparse.Namespace()

ARGS.trials = 10000
ARGS.x_max = 200

def main ():
    s = 0
    for trial in range(ARGS.trials):
        r = random.randrange(2)
        x = random.randrange(1, ARGS.x_max + 1)
        if r == 0:
            a = x * 2
            b = x
        else:
            a = x
            b = x * 2
        s += np.array([a, b, x, b/a, a/b])
    av = s / ARGS.trials

    print("E(A) =", av[0])
    print("E(B) =", av[1])
    print("E(X) =", av[2])
    print("E(B/A) =", av[3], "(== 1.25)")
    print("E(A/B) =", av[4], "(== 1.25)")
    print("E(B)/E(A) =", av[1] / av[0], "(== 1.00)")

if __name__ == '__main__':
    main()
</source>

実行結果は次のようになる。

<source>
$ python two_envelopes_1.py
E(A) = 151.2315
E(B) = 149.3442
E(X) = 100.1919
E(B/A) = 1.2425 (== 1.25)
E(A/B) = 1.2575 (== 1.25)
E(B)/E(A) = 0.9875204570476388 (== 1.00)
</source>

B/A の平均は 1.25 近くになっているが、B の平均を A の平均で割ったもの
はほぼ 1.0 である。B にかならず交換したとしても得をしないことがわかる。

にもかかわらず E(B/A) は 1.0 ではない。これは少し不思議だが、E(X)/E(Y)
が 1 になっても、E(X/Y) が 1 になるとは限らないのはよくあることだ。例え
ば、サイコロを二個振ってその目(X と Y)どうしを割ると、E(X)/E(Y) = 1 だ
が、E(X/Y) = 1.428166... となる (div_of_dice.py で答えを求めている)。

つまり、1.25倍といって求めているのは、単に、相手を見たとき相手の額が自
分の何倍かを調べると平均で 1.25 倍(2倍と1/2倍の中間)になるということな
のである。交換したとしてもしなかったとしてもそうなる。もちろん、交換す
れば結果が変わるかというと変わらない…となる。

開封か未開封かは疑似問題に過ぎない。「隣の芝生は青い」というのの数学的
根拠にはなるかもしれないが。…とひとまず私は結論したのだった。

ここで一応確認のため「1万円と固定した場合は異る」のだから、固定した場
合のシミュレーションもやってみておくか…と作ったのが次の
two_envelopes_2.py である。なお、少ない試行で答えを得るために 1万円 で
はなく 50 円で試している。

<source>
import random
import numpy as np
import argparse
ARGS = argparse.Namespace()

ARGS.trials = 100000
ARGS.x_max = 200
ARGS.q = 50

def main ():
    s = 0
    valid = 0
    for trial in range(ARGS.trials):
        r = random.randrange(2)
        x = random.randrange(1, ARGS.x_max + 1)
        if r == 0:
            a = x * 2
            b = x
        else:
            a = x
            b = x * 2
        if ARGS.q != a:
            continue
        valid += 1
        s += np.array([a, b, x, b/a, a/b])
    av = s / valid

    print("valid: ", valid, "/", ARGS.trials)
    print("E(A) =", av[0])
    print("E(B) =", av[1])
    print("E(X) =", av[2])
    print("E(B/A) =", av[3])
    print("E(A/B) =", av[4])
    print("E(B)/E(A) =", av[1] / av[0])

if __name__ == '__main__':
    main()
</source>

実行結果は次のようになる。

<source>
$ python two_envelopes_2.py
valid:  531 / 100000
E(A) = 50.0
E(B) = 61.440677966101696
E(X) = 37.14689265536723
E(B/A) = 1.228813559322034
E(A/B) = 1.271186440677966
E(B)/E(A) = 1.228813559322034
</source>

なんと、E(B/A) はもちろん、E(B)/E(A) もほぼ 1.25 になっている！ 交換は
確かに得になるのだ！

なぜ、こんなことが起こるのだろう。それを調べるために…

<source>
        if ARGS.q != a:
            continue
</source>

…の部分で、 ARGS.q != a すなわち 50 != a でなく 50 != a and 51 != a
と変えてみると、E(B)/E(A) は 1.5 ぐらいになる。50 != a and 52 != a に
すると、E(B)/E(A) は 1.25 に戻る。210 != a にすると、E(B)/E(A) は 0.5
になる。

どうも上限 ARGS.x_max が結果に関係しているようだ。また、a が偶数か奇数
かも問題になっているようだ。まず、上限に関して調べるためにこの問題の額
を実数を取るものに拡張してみる。それが「その２ 実数拡張編」になる。


** 参考

この記事には、その１ 基礎編、その２ 実数拡張編、その３ 整数拡張編がある。

まず、参考文献として最初に挙げるべきは…

  * 『改定版 可能世界の哲学 - 「存在」と「自己」を考える』(三浦 俊彦
    著, 二見文庫, 2017年)。今回のネタ本。様相論理について載っている。

    https://www.amazon.co.jp/dp/4576170619

一連の記事を書いたあと、ググったりして関連を調べた。二封筒問題は有名な
問題で、私と同様の解答をしているものがすでにあるだろうと思ったが、まっ
たく同じものは見つけられなかった。ただ、私に理解できない記述も多かった
ため、私のやったことを包含してさらに難しく論じたものもあるものと思われ
る。そもそも私が問題を理解できていないという可能性も認めねばならない。
そういった中で私の結論に近そうなものを一つだけ挙げておくと以下になるか。

  * 《封筒のパラドックス。。。５。。。シミュレーション編。。。 : 来生
    自然の。。。》

    https://jinen.exblog.jp/5875263/

三浦俊彦の紹介する問題の関連も挙げておく。

  * 《眠り姫問題のプログラム - JRF のソフトウェア》。三浦俊彦『多宇宙
    と輪廻転生 - 人間原理のパラドクス』で紹介している問題に対する私の
    解答。

    http://jrf.cocolog-nifty.com/software/2017/02/post-1.html

  * 《モンティ・ホール問題または三囚人問題の拡張とその確率操作シミュレー
    ション - JRF のソフトウェア》。以前、私が書いた記事。ベイズの定理
    を用いた推論で、直観に反するものの有名な例を詳しめに解説している。

    http://jrf.cocolog-nifty.com/software/2016/08/post.html
    
  * 《シミュレーション・アーギュメントを論駁する - JRF の私見：宗教と
    動機付け》。三浦俊彦『ゼロからの論証』にも載っているシミュレーショ
    ン・アーギュメントについて私が論じた記事。この宇宙は巨大なシミュレー
    ションなのか？……という問題。
    
    http://jrf.cocolog-nifty.com/religion/2006/10/post.html

  * [cocolog:86854015] で、終末論法を少し論じている。そこは、三浦俊彦
    『多宇宙と輪廻転生 - 人間原理のパラドクス』の紹介を行う「ひとこと」
    である。

    http://jrf.cocolog-nifty.com/statuses/2017/02/post-f18d.html


** 著者

JRF ( http://jrf.cocolog-nifty.com/software/ )


** ライセンス

私が作った部分に関してはパブリックドメイン。 (数式のような小さなプログ
ラムなので。)

自由に改変・公開してください。



    二封筒問題のシミュレーション その２ 実数拡張編


** 概要

二封筒問題(参: 三浦俊彦『可能世界の哲学』)を Python を用いたシミュレー
ションで解く。その１では未開封と開封で答えが違うことがシミュレーション
によっても確かめられた。

この「その２」ではその謎を探るため、まずは上限の効果を確かめようと額を
実数にするよう問題を拡張してみる。

この次の「その３」では整数問題に戻って拡張を試みる。


** 実数拡張

その１のシミュレーションでは、暗黙のうちに小切手の額は整数であると考え
た。しかし、整数だと一方を2倍にするときに、両者の中間的な状態がわから
なくなる感じ、中がくぼんでいるイメージがあるように私は思った。それが解
析を難しくしていると感じた。

そこで、もっと状態が稠密であるようにすればよいのではないかと、額を実数
にすることを考えてみる。具体的には、乱数を上限 X 円で一様乱数を発生さ
せて、x という額をランダムに決めたあと、コインで表裏を決める…すなわち
0 か 1 かの乱数 r をとり、r == 0 ならば、a の封筒に 2*x/3 円、b の
封筒に x/3 円入れ、r == 1 ならば a の封筒に x/3 円、b の封筒に 2*x/3
円入れるという風にやってみる。

それをするプログラムが two_envelopes_3.py で以下のようになる。
(parse_args を省略している。)

<source>
import random
import numpy as np
from sympy import *
import argparse
ARGS = argparse.Namespace()

ARGS.trials = 10000
ARGS.x_max = 200
ARGS.q = 0

def main ():
    s = 0
    valid = 0
    for trial in range(ARGS.trials):
        r = random.randrange(2)
        x = random.uniform(0, ARGS.x_max)
        if r == 0:
            a = 2 * x / 3
            b = x / 3
        else:
            a = x / 3
            b = 2 * x / 3
        if a > ARGS.x_max / 3 + ARGS.q:
            continue;
        valid += 1
        s += np.array([a, b, x, b / a])
    av_c = s / valid

    x = Symbol('x', real=True)
    X = Symbol('X', real=True)
    E_a1_b = integrate(Rational(1, 3) * x / (X / 2), (x, 0, X / 2))
    E_b_b = integrate(Rational(2, 3) * x / X, (x, 0, X))
    E_c_b = Rational(1, 3) * E_a1_b + Rational(2, 3) * E_b_b
    assert Eq(E_a1_b, X * Rational(1, 12)).simplify()
    assert Eq(E_b_b, X * Rational(1, 3)).simplify()
    assert Eq(E_c_b, X * Rational(1, 4)).simplify()

    E_a1_a = integrate(Rational(2, 3) * x / (X / 2), (x, 0, X / 2))
    E_b_a = integrate(Rational(1, 3) * x / X, (x, 0, X))
    E_c_a = Rational(1, 3) * E_a1_a + Rational(2, 3) * E_b_a
    assert Eq(E_a1_a, X * Rational(1, 6)).simplify()
    assert Eq(E_b_a, X * Rational(1, 6)).simplify()
    assert Eq(E_c_a, X * Rational(1, 6)).simplify()

    E_a1_ba = integrate(Rational(1, 2) / (X / 2), (x, 0, X / 2))
    E_b_ba = integrate(2 / X, (x, 0, X))
    E_c_ba = Rational(1, 3) * E_a1_ba + Rational(2, 3) * E_b_ba
    assert Eq(E_a1_ba, Rational(1, 2)).simplify()
    assert Eq(E_b_ba, 2).simplify()
    assert Eq(E_c_ba, Rational(3, 2)).simplify()

    E_c_a = E_c_a.subs([(X, ARGS.x_max)]).evalf()
    E_c_b = E_c_b.subs([(X, ARGS.x_max)]).evalf()
    E_c_ba = E_c_ba.subs([(X, ARGS.x_max)]).evalf()

    print("valid:", valid, "/", ARGS.trials)
    if ARGS.q == 0:
        print("E(A) =", av_c[0], "(==", E_c_a, ")")
        print("E(B) =", av_c[1], "(==", E_c_b, ")")
        print("E(X) =", av_c[2])
        print("E(B/A) =", av_c[3], "(==", E_c_ba, ")")
        print("E(B)/E(A) =", av_c[1] / av_c[0], "(==", E_c_b / E_c_a, ")")
    else:
        print("E(A) =", av_c[0])
        print("E(B) =", av_c[1])
        print("E(X) =", av_c[2])
        print("E(B/A) =", av_c[3])
        print("E(B)/E(A) =", av_c[1] / av_c[0])

if __name__ == '__main__':
    main()
</source>

ソースの説明の前に実行結果を先に見ておこう。

<source>
$ python two_envelopes_3.py
valid: 7525 / 10000
E(A) = 33.37136761864975 (== 33.3333333333333 )
E(B) = 49.86177523537428 (== 50.0000000000000 )
E(X) = 83.23314285402402
E(B/A) = 1.4948837209302326 (== 1.50000000000000 )
E(B)/E(A) = 1.4941483910748923 (== 1.50000000000000 )
</source>

ソースの main は大きくわけて三つの部分からなる。

最初の for によるループでシミュレーションを実行している。開封バージョ
ンのような結果を得るために、基本、a <= ARGS.x_max / 3 のものだけ valid
(妥当)な試行として数えている。ARGS.x_max が上でいう上限 X である。
ARGS.q についてはあとで説明する。

次の x = Symbol('x', real=True) から print の前までが、期待値の計算で
ある。

「assert 式」は、式が真でない場合、エラーを出力するもので逆に言えば、
そこでの計算結果が満たすべき式を表している。通常みないのは 「assert
Eq(■, □).simplify()」という式である。これは、sympy を使ったシンボル
を含む式な単純な == では文字通りの比較をされて偽と判断されるためそうな
らないようにしているだけで、いいたいことは ■ == □ である。

例えば、「assert Eq(E_a1_b, X * Rational(1, 12)).simplify()」 は
E_a1_b が X/12 になることを確かめているだけである。Rational(1, 12) は
1/12 のことである。

さて期待値の計算であるが、本当は、a が開封されて a だけが見れるわけで
はあるが、期待値の計算上はどちらを二倍にするかの r も見ることができる
としても問題ない。そこで、事象を次の 3 つの領域に分類する。

  * 領域 a1: r == 0 で、x <= X/2。

  * 領域 a2: r == 0 で、x > X/2。

  * 領域 b: r == 1 で、すべての x。

上でチェックしている a <= X/3 であるが、r == 1 の場合、a は x/3 である
ことが確定し x/3 <= X/3 なので、かならず言える。r == 0 の場合、a は
2*x/3 であるが、x <= X/2 ならば a <= X/3 に、x > X/2 ならば a > X/3 と
なる。ゆえに、

  * 領域 c: a <= X/3。

とすると、領域 c = 領域 a1 と 領域 b の和集合…となる。

領域 c における b の封筒に入っている額の期待値を求めたいならば、領域
a1 と領域 b に分割して両者の期待値を計算してから重み付けして足し合わせ
ればいい。ちなみに、「期待値の分割」の公式は↓などにあるが、離散版しか
証明を載せているところしか見つからず、実数版は私は見つけることができな
かった。自明のようにも思うが、ここでは証明なしに「期待値の分割」の公式
を使う。

《期待値 - COMPASS 真の理解のためのシンプルな数学のノート》  
http://www.compassare.org/mean.html

領域 a1 における b の期待値は、ソースを見ればわかるかと思うが、

<source>
  E_a1_b = integrate(Rational(1, 3) * x / (X / 2), (x, 0, X / 2))
</source>

として式を建てる。E(f(X)) == integrate(f(X) * p(x), x) という定義的式
と一様分布の p(x) = 1/(X/2) を使った。これは、結局、E_a1_b == X/12 の
ように求まる。

それを領域 b における b の期待値とともに「期待値の分割」の公式を使って
まとめているのが、

<source>
  E_c_b = Rational(1, 3) * E_a1_b + Rational(2, 3) * E_b_b
</source>

で、結局、領域 c における b の期待値 E_c_b == X / 4 と求まる。

同様にして、領域 c における a の期待値 E_c_a == X/6、領域 c における
b/a の期待値 E_c_ba == 3/2 が求まる。

あと、E_c_a = E_c_a.subs([(X, ARGS.x_max)]).evalf() は X にそのときの
上限の実際の値を入れて計算するものである。

そして、最後にシミュレーション結果と ARGS.q == 0 のときは期待値を表示
する。

これが上の two_envelopes_3.py がやっていることである。

これにより、開封後 a が X/3 以下であれば…すなわち、領域 c において…
a から b に交換したときの期待値が 1.5 倍になることが示された。


** ARGS.q の使い方

さて、if a > ARGS.x_max / 3 + ARGS.q: の部分を変え、valid となる範囲を
いろいろ変えて実験していくと、どうも、E(b)/E(a) の期待値の最大値は 1.5
らしいとわかってくる。それを簡単に試してもらうため ARGS.q に様々な値を
代入していただこうというのが、ARGS.q を設けた目的である。

ARGS.q を正の値にすると、valid でないとして reject される範囲が狭まり、
領域 a2 のものが計算に加わることになる。上では示していないが、領域 a2
は交換が不利になるため、その領域を含むことで、E(b)/E(a) の結果は悪くな
る。例えば ARGS.q == +30 とすると次のようになる。

<source>
$ python two_envelopes_3.py -q +30
valid: 8617 / 10000
E(A) = 39.59189449016641
E(B) = 48.976348351691456
E(X) = 88.568242841858
E(B/A) = 1.368631774399443
E(B)/E(A) = 1.2370296744414668
</source>

一方、ARGS.q を負の値にすると、valid な範囲が狭まるわけであるが、それ
は a1 の領域が食い込むだけで、E(b)/E(a) には影響を及ぼさない。例えば
ARGS.q == -30 にすると次のようになる。

<source>
$ python two_envelopes_3.py -q -30
valid: 4095 / 10000
E(A) = 18.56406053629886
E(B) = 28.04892252471019
E(X) = 46.612983061009025
E(B/A) = 1.5084249084249084
E(B)/E(A) = 1.5109260428161875
</source>

E(b)/E(a) の最大は 1.5 で、最大の 1.5 に保ったまま reject されない…す
なわち得をする機会を見逃さないのが、a <= X/3 という基準であると言えそ
うだ。

しかし、それはデータからそう言えるだけで論理的にそうだと証明できたわけ
ではない。

開封によって知ることができ、かつ、その知ったことによって変化させること
ができる事象というものが、はっきり列挙されているわけではないのがここで
は問題となる。

知ること／知らないことをどう表すか…それが問われていると言えるかもしれ
ない。

なお、中身を見れず額がわからなくとも、上限額よりはるかに小さい額しか入っ
ていないという情報があれば、a <= X/3 を確かめるための X の具体的な数値
が示されないということであっても、交換が有利になるとは言えるだろう。た
だ、分布が一様分布でないというような情報になれば、また話は変わってくる
だろう。

さて、この続きの「その３」では、整数に戻って元の二封筒問題がなぜそのよ
うな答えになるかの私なりの「完全な解答」を与えよう。


** 参考＆著者＆ライセンス

この記事には、その１ 基礎編、その２ 実数拡張編、その３ 整数拡張編があ
るが、その１を参照のこと。



    二封筒問題のシミュレーション その３ 整数拡張編


** 概要

二封筒問題(参: 三浦俊彦『可能世界の哲学』)を Python を用いたシミュレー
ションで解く。その１では未開封と開封で答えが違うことがシミュレーション
によっても確かめられた。その謎を解くため、その２では、まずは額を実数に
するよう問題を拡張した。

この「その３」では整数問題に戻って拡張を試み、謎の解明を完成する。


** 整数拡張

その２の実数拡張では、額の上限が与える影響を示すことができた。整数では
さらに、額が偶数か奇数かがさらなる問題となる。具体的には、開封して奇数
であれば、それは相手の二倍でないのは確実なので、交換するのがどうみても
得になるわけである。

それを解析していこう。シミュレーションは実数拡張と似ているが、期待値
(平均値)を直接求めるのではなく、試行をすべてメモリにたくわえてあとで処
理するというある意味 Python らしいメモリをたくさん使った実装にしてみた。

プログラムは次の two_envelopes_4.py である。parse_args をはじめいろいろ省
略している。ARGS.x_max すなわち X は、偶数でなければならないとする。

<source>
import random
import numpy as np
from sympy import *
import argparse
ARGS = argparse.Namespace()

ARGS.trials = 10000
ARGS.x_max = 200

# parse_args 省略

def main ():
    trials = []
    for trial in range(ARGS.trials):
        r = random.randrange(2)
        x = random.randrange(1, ARGS.x_max + 1)
        if r == 0:
            a = x * 2
            b = x
        else:
            a = x
            b = x * 2
        trials.append([a, b, r, x, b / a])
    trials = np.array(trials)
    t_a = trials[:, 0]
    t_b = trials[:, 1]
    t_r = trials[:, 2]
    t_x = trials[:, 3]
    t_a1 = trials[(t_x <= ARGS.x_max / 2) & (t_r == 0)]
    t_a2 = trials[(t_x > ARGS.x_max / 2) & (t_r == 0)]
    t_be = trials[(t_r == 1) & (t_x % 2 == 0)]
    t_bo = trials[(t_r == 1) & (t_x % 2 == 1)]
    t_c = trials[(t_a <= ARGS.x_max) & (t_a % 2 == 0)]
    t_d = trials[t_a <= ARGS.x_max]
    t_a2_ = trials[t_a > ARGS.x_max]
    t_bo_ = trials[t_a % 2 == 1]
    assert t_a1.shape[0] + t_be.shape[0] == t_c.shape[0]
    assert t_c.shape[0] + t_bo.shape[0] == t_d.shape[0]
    assert np.all(t_a2 == t_a2_)
    assert np.all(t_bo == t_bo_)
    
    x = Symbol('x', integer=True)
    X = Symbol('X', real=True)
    y = Symbol('y', integer=True)

    n_a1 = summation(1, (x, 1, X/2))
    n_a2 = summation(1, (x, X/2 + 1, X))
    n_be = summation(1, (y, 1, X/2))
    n_bo = summation(1, (y, 1, X/2))

    E_a1_b = summation(x, (x, 1, X/2)) / n_a1
    E_a2_b = summation(x, (x, X/2 + 1, X)) / n_a2
    E_be_b = summation((2 * x).subs([(x, 2 * y)]), (y, 1, X / 2)) / n_be
    E_bo_b = summation((2 * x).subs([(x, 2 * y - 1)]), (y, 1, X / 2)) / n_bo
    E_c_b = (n_a1 / (n_a1 + n_be)) * E_a1_b + (n_be / (n_a1 + n_be)) * E_be_b
    E_d_b = (n_a1 / (n_a1 + n_be + n_bo)) * E_a1_b \
        + (n_be / (n_a1 + n_be + n_bo)) * E_be_b \
        + (n_bo / (n_a1 + n_be + n_bo)) * E_bo_b
    E_omega_b = ((n_a1 + n_be) / (n_a1 + n_a2 + n_be + n_bo)) * E_c_b \
        + (n_a2 / (n_a1 + n_a2 + n_be + n_bo)) * E_a2_b \
        + (n_bo / (n_a1 + n_a2 + n_be + n_bo)) * E_bo_b
    assert Eq(E_a1_b, X/4 + 1/2).simplify()
    assert Eq(E_a2_b, 3*X/4 + 1/2).simplify()
    assert Eq(E_be_b, X + 2).simplify()
    assert Eq(E_bo_b, X).simplify()
    assert Eq(E_c_b, 5*X/8 + 5/4).simplify()
    assert Eq(E_d_b, 3*X/4 + 5/6).simplify()
    assert Eq(E_omega_b, 3*X/4 + 3/4).simplify()

# E_c_a, E_d_ba などを求めるのを省略。

    f = lambda q: q.subs([(X, ARGS.x_max)]).simplify().evalf()

    print("Realm: c")
    av_c = np.mean(t_c, axis=0)
    print("valid:", t_c.shape[0], "/", ARGS.trials)
    print("E(A) =", av_c[0], "(==", f(E_c_a), ")")
    print("E(B) =", av_c[1], "(==", f(E_c_b), ")")
    print("E(X) =", av_c[3])
    print("E(B/A) =", av_c[4], "(==", f(E_c_ba), ")")
    print("E(B)/E(A) =", av_c[1] / av_c[0], "(==", f(E_c_b / E_c_a), ")")

# 領域 a2, bo, d に関する print を省略

    assert Eq(E_d_b/E_d_a, (9 * X + 10) / (6 * X + 8)).simplify()
    #plot(E_d_b/E_d_a, (X, 0, 100))

# 領域 Omega に関する print を省略

if __name__ == '__main__':
    # parse_args 省略
    main()

</source>

ソースの説明の前に実行結果は次のようになる。

<source>
$ python two_envelopes_4.py
Realm: c
valid: 5040 / 10000
E(A) = 101.04166666666667 (== 101.000000000000 )
E(B) = 125.7 (== 126.250000000000 )
E(X) = 75.58055555555555
E(B/A) = 1.2407738095238094 (== 1.25000000000000 )
E(B)/E(A) = 1.244041237113402 (== 1.25000000000000 )

Realm: a2
valid: 2494 / 10000
E(A) = 301.0208500400962 (== 301.000000000000 )
E(B) = 150.5104250200481 (== 150.500000000000 )
E(X) = 150.5104250200481
E(B/A) = 0.5 (== 0.500000000000000 )
E(B)/E(A) = 0.5 (== 0.500000000000000 )

Realm: bo
valid: 2466 / 10000
E(A) = 99.07948094079481 (== 100.000000000000 )
E(B) = 198.15896188158962 (== 200.000000000000 )
E(X) = 99.07948094079481
E(B/A) = 2.0 (== 2.00000000000000 )
E(B)/E(A) = 2.0 (== 2.00000000000000 )

Realm: d
valid: 7506 / 10000
E(A) = 100.39701572075673 (== 100.666666666667 )
E(B) = 149.5054622968292 (== 150.833333333333 )
E(X) = 83.30082600586198
E(B/A) = 1.4902078337330136 (== 1.50000000000000 )
E(B)/E(A) = 1.4891424931659545 (== 1.49834437086093 )

Realm: Omega
valid: 10000
E(A) = 150.4326 (== 150.750000000000 )
E(B) = 149.7561 (== 150.750000000000 )
E(X) = 100.0629
E(B/A) = 1.24325 (== 1.25000000000000 )
E(B)/E(A) = 0.9955029694361461 (== 1.00000000000000 )
</source>

ソースの説明をする。

最初に for 文でシミュレーションをしている。これまでの違いは、試行を足
し合わせるのではなく trials というリストに残している点である。

そして後から、numpy の機能を使って、trials を領域の条件を満たすかどう
かで分類している。基本となる領域 a1, a2, be, bo は次のようになる。なお、
X を ARGS.x_max のこととする。r == 0 で a が二倍、r == 1 で b が二倍に
なる。

  * 領域 a1: r == 0 で、x <= X/2。
  * 領域 a2: r == 0 で、x > X/2。
  * 領域 be: r == 1 で、x が偶数(even)。
  * 領域 bo: r == 1 で、x が奇数(odd)。
  
そしてそれらの組み合わせと等しくなるのが領域 c, d, Omega である。

  * 領域 c: a <= X かつ a が偶数。
  * 領域 d: a <= X。
  * 領域 Omega: 全領域。

なお、領域 c は 領域 a1 と be を組み合わせになり、領域 d は 領域 c と
bo を組み合わせたものになる。また、領域 a2 は、a > X の領域と合致し、
領域 bo は a が奇数の領域と合致する。それは、assert で結果から確かめ
てもいる。

次にそれぞれの領域における b と a と b/a の期待値を求めている。

例えば、領域 c における b に交換したときの期待値は E_c_b として式を建
てている。それは、期待値の分割を使って E_a1_b と E_be_b から求められる。

<source>
  E_c_b = (n_a1 / (n_a1 + n_be)) * E_a1_b + (n_be / (n_a1 + n_be)) * E_be_b
</source>

そして例えば領域 a1 における b の期待値は E_a1_b は、n_a1 が領域 a1 の
すべての場合の数だとして

<source>
  E_a1_b = summation(x, (x, 1, X/2)) / n_a1
</source>

…になる。これは assert 文でわかるように結局、E_a1_b ==  X/4 + 1/2 と
なる。assert の読み方はその２で説明したのでそちらを参照していただきた
い。そして、E_c_b == 5*X/8 + 5/4 となる。

そして最後に a の開封によって観測できる各領域ごとに E(a), E(b), E(x),
E(b/a), E(b)/E(a) を表示している。

蛇足だが、領域 d における E(B)/E(A) はほぼ 1.5 になるが、厳密には 1.5
に満たなくなるようだ。E_d_b/E_d_a == (9 * X + 10) / (6 * X + 8) となる。
これを plot すると次のようになる。100 ですでに 1.5 近いから 10000 あた
りになれば、ほぼ 1.5 になるのだが、ご参考まで。

{{fig_E_d_b_E_d_a.png}}

以上が、two_envelopes_4.py の説明である。

その結果、領域 c では、b への交換が 1.25 倍有利になっている。しかし、
領域 a2 では逆に 0.5 倍となり不利になっている。また、領域 bo では 2.0
倍になり 1.25 倍よりさらに有利になっている。結果全領域ではいろいろな
効果が打ち消しあって 1.0 倍…すなわち変わらないということになるが、こ
れはかなり偶然が重なってのことであるという印象を受ける。


** 「二封筒問題」の結論

さて、開封して 1万円だとわかった場合という二封筒問題の開封バージョンの
条件は、一目して受ける印象と違ってかなり条件が制限されたものだというの
がわかる。

それは領域 c に属するということ、つまり、最初に決める額の上限額X (本当
の上限は 2*X) より開封して見た額 a が小さく、かつ、偶数の額であるとい
うこと…それが 1.25 倍という結果を導いているのである。

もし、上限 X が例えば 9000円であれば、開封した a が1万円になることは可
能だが、交換は 1.25 倍とはならならず 0.5 倍となる。そういう不利な条件
がまず排除されている。

さらに開封した額 a が 9999円のような奇数なら交換はからなず 2 倍となる。
そういう有利な条件もまた排除されているということになる。

未開封なら 1倍というところから、そういう有利なところと不利なところを刈
りこんだら 1.25 倍の領域が残ったというのが、この問題の謎の解になろう。

領域 c にあることと、1万円だとわかることには違いがある。開封して 1万円
だとわかったときの期待値の計算は、三浦の最初の計算で正しいのだろう。謎
は、開封した場合ではなく未開封の場合で、それは今回領域 Omega として計
算したようになる。…ということなのではないか。


** 今後に向けて

その２と同じく、中身を見れず額がわからなくとも、上限額よりはるかに小さ
い額しか入っていないという情報があれば、交換が有利になるとは言えるだろ
う。額が偶数だろうが奇数だろうがそれが言える…と。ただ、分布が一様でな
いなら難しくはなるが…。

その２の最後でも書いたが、ところで「開封」とは、どういう意味を数学・論
理学的に持つのだろうか？

開封によって知ることができ、かつ、その知ったことによって変化させること
ができる事象というものが、実は、はっきり列挙されているわけではない。知
ること／知らないことをどう表すか…それが問われていると言えるかもしれな
い。

領域の分け方はこれ以外ありえないのか、それは証明されていない。この問題
に関しては、これ以上の場合わけの方法はないと私には思われるが、それで十
分という保証があるわけではない。

領域 c に属すことと、1万円とわかることには違いがある。領域 c に属す各
要素について、同じ期待値を保証するということができれば、例えば特定のサ
イズの魚が池にいた確率のような実数値の議論にも応用できるのかもしれない。
それはどうすればできるのか、私はその方法を知っていない。その一般的性質・
どういうときできるかも興味がある。それを知るのも今後の課題だろう。


** 参考＆著者＆ライセンス

この記事には、その１ 基礎編、その２ 実数拡張編、その３ 整数拡張編があ
るが、その１を参照のこと。



(This document is written in Japanese/UTF-8.)
